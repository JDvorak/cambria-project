<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Chitin, v4: Op Log Example | Cambria Development Notes</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.73.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/cambria/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    <link href="/cambria/article.css"/>

    
      <link rel="stylesheet" href="/cambria/article.css">
    

    
      

    

    
    
    <meta property="og:title" content="Chitin, v4: Op Log Example" />
<meta property="og:description" content="Here&rsquo;s a concrete example to illustrate how the &ldquo;op log&rdquo; based Chitin 4 system works, and then some brief explanation of why it&rsquo;s better than our previous iterations.
Let&rsquo;s say we have three related schemas for a Task (listed below), which have evolved as we develop the app. Our goal is that clients can read/write to the same document using any of the schemas.
V1 {title: stringdescription: string}// - rename title to name// - add a complete booleanV2 {name: stringdescription: stringcomplete: boolean}// - change the complete boolean to a 3-valued &quot;status&quot; fieldV3 {name: stringdescription: stringstatus: string}In Chitin 4, writes are straightforward." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://inkandswitch.github.io/cambria/designs/chitin-v4/" />
<meta property="article:published_time" content="2020-07-07T09:47:58-07:00" />
<meta property="article:modified_time" content="2020-07-07T09:47:58-07:00" />
<meta itemprop="name" content="Chitin, v4: Op Log Example">
<meta itemprop="description" content="Here&rsquo;s a concrete example to illustrate how the &ldquo;op log&rdquo; based Chitin 4 system works, and then some brief explanation of why it&rsquo;s better than our previous iterations.
Let&rsquo;s say we have three related schemas for a Task (listed below), which have evolved as we develop the app. Our goal is that clients can read/write to the same document using any of the schemas.
V1 {title: stringdescription: string}// - rename title to name// - add a complete booleanV2 {name: stringdescription: stringcomplete: boolean}// - change the complete boolean to a 3-valued &quot;status&quot; fieldV3 {name: stringdescription: stringstatus: string}In Chitin 4, writes are straightforward.">
<meta itemprop="datePublished" content="2020-07-07T09:47:58-07:00" />
<meta itemprop="dateModified" content="2020-07-07T09:47:58-07:00" />
<meta itemprop="wordCount" content="981">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Chitin, v4: Op Log Example"/>
<meta name="twitter:description" content="Here&rsquo;s a concrete example to illustrate how the &ldquo;op log&rdquo; based Chitin 4 system works, and then some brief explanation of why it&rsquo;s better than our previous iterations.
Let&rsquo;s say we have three related schemas for a Task (listed below), which have evolved as we develop the app. Our goal is that clients can read/write to the same document using any of the schemas.
V1 {title: stringdescription: string}// - rename title to name// - add a complete booleanV2 {name: stringdescription: stringcomplete: boolean}// - change the complete boolean to a 3-valued &quot;status&quot; fieldV3 {name: stringdescription: stringstatus: string}In Chitin 4, writes are straightforward."/>

	
  </head>

  <body class="ma0 bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/cambria/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Cambria Development Notes
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        DESIGNS
      </aside>
      <h1 class="f1 mt3 mb1">Chitin, v4: Op Log Example</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-07-07T09:47:58-07:00">July 7, 2020</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>Here&rsquo;s a concrete example to illustrate how the &ldquo;op log&rdquo; based Chitin 4 system works, and then some brief explanation of why it&rsquo;s better than our previous iterations.</p>
<p>Let&rsquo;s say we have three related schemas for a Task (listed below), which have evolved as we develop the app. Our goal is that clients can read/write to the same document using any of the schemas.</p>
<pre><code>V1 {
  title: string
  description: string
}

// - rename title to name
// - add a complete boolean

V2 {
  name: string
  description: string
  complete: boolean
}

// - change the complete boolean to a 3-valued &quot;status&quot; field

V3 {
  name: string
  description: string
  status: string
}
</code></pre><p>In Chitin 4, writes are straightforward. When a client writes a change, we append an operation to an append-only stream, containing the content of the edit and some metadata about which schema they used. The edit contents are described from the perspective of the writer&rsquo;s schema;  for example, the first patch, from a client using the v1 schema, sets the &ldquo;title&rdquo; property because that&rsquo;s the name of the property for that client.</p>
<pre><code>            set title to      set description     set complete       
             &quot;laundry&quot;       to &quot;wash clothes&quot;       to true         
                ┌────┐            ┌────┐             ┌────┐          
Raw patches ────┤ v1 ├────────────┤ v3 ├─────────────┤ v2 ├─────────▶
                └────┘            └────┘             └────┘          
</code></pre><p>Now, let&rsquo;s say we want to read this document using the v3 schema. We map over the log of patches and create a new log of corresponding patches in the v3 schema. Notice how the first patch changed a property name, and the third patch converted <code>complete: true</code> to <code>status: &quot;done&quot;</code>.</p>
<pre><code>            set title to      set description     set complete       
             &quot;laundry&quot;       to &quot;wash clothes&quot;       to true         
                ┌────┐            ┌────┐             ┌────┐          
Raw patches ────┤ v1 ├────────────┤ v3 ├─────────────┤ v2 ├─────────▶
                └────┘            └────┘             └────┘          
                   │                 │                  │            
                   │                 │                  │            
                   ▼                 ▼                  ▼            
                ┌────┐            ┌────┐             ┌────┐          
 V3 Patches ────┤ v3 ├────────────┤ v3 ├─────────────┤ v3 ├─────────▶
                └────┘            └────┘             └────┘          
             set name to       set description     set status        
              &quot;laundry&quot;       to &quot;wash clothes&quot;    to &quot;done&quot;         
</code></pre><p>As a brief aside, this process of mapping patches is handled by the Cloudina lens library. We won&rsquo;t go into deep detail on that part here, but some basics:</p>
<p>The user defined some <em>lenses</em>: logic for converting patches between pairs of schemas, and we use those lenses in the conversion process.</p>
<p>Sometimes a patch needs to be converted across more than one lens. The first patch in this example had to be converted from v1 to v3, but there&rsquo;s no lens directly connecting those two schemas. So we find a path between them, by converting the patch first from a v1 patch to a v2 patch (applying a property rename), and then from a v2 patch to a v3 patch (doing nothing to the patch, because the name field is left untouched in that lens).</p>
<pre><code>set title to ┌────┐
 &quot;laundry&quot;   │ v1 │
             └────┘
                │  
                ▼  
 set name to ┌────┐
  &quot;laundry&quot;  │ v2 │
             └────┘
                │  
                ▼  
 set name to ┌────┐
  &quot;laundry&quot;  │ v3 │
             └────┘
</code></pre><p>Alright, so now we have a stream of patches to a V3 document. All that&rsquo;s left is to reduce over the stream of patches, to produce a final document in the V3 schema!</p>
<pre><code>            set title to      set description     set complete                                           
             &quot;laundry&quot;       to &quot;wash clothes&quot;       to true                                             
                ┌────┐            ┌────┐             ┌────┐                                              
Raw patches ────┤ v1 ├────────────┤ v3 ├─────────────┤ v2 ├─────────▶                                    
                └────┘            └────┘             └────┘                                              
                   │                 │                  │               V3 Document                      
                   │                 │                  │             ┌─────────────────────────────────┐
                   ▼                 ▼                  ▼             │{                                │
                ┌────┐            ┌────┐             ┌────┐           │  name: &quot;laundry&quot;,               │
 V3 Patches ────┤ v3 ├────────────┤ v3 ├─────────────┤ v3 ├─────────▶ │  description: &quot;wash clothes&quot;,   │
                └────┘            └────┘             └────┘           │  status: &quot;todo&quot;                 │
             set name to       set description     set status         │}                                │
              &quot;laundry&quot;       to &quot;wash clothes&quot;    to &quot;done&quot;          └─────────────────────────────────┘
</code></pre><p>We&rsquo;ve found that this design combines a number of desirable characteristics. Here are two of the more subtle ones.</p>
<h2 id="reinterpreting-the-past">Reinterpreting the past</h2>
<p>Because no conversions happen on write, it&rsquo;s always possible to go back and reinterpret the history of edits through a different set of lenses. This turns out to be important in asynchronous collaboration. Let&rsquo;s say Alice goes offline and makes some edits, while Bob is adding new lenses and schemas. When Alice comes back online and her edits appear, Bob should be able to read them through his new schema, even though Alice&rsquo;s client didn&rsquo;t have access to his new lenses when it was making writes. This design supports that use case great, because Bob&rsquo;s client is free to interpret Alice&rsquo;s writes through any set of lenses available on his client.</p>
<h2 id="patches-not-documents">Patches, not documents</h2>
<p>A second feature here is that the fundamental unit of conversions is <em>patches</em>, rather than documents. We&rsquo;ve found that this helps preserve user intent through lens conversions and generally allows for more sensible behavior. Here&rsquo;s a concrete example:</p>
<p>A V3 task has <code>status: &quot;inProgress&quot;</code>. In V1, this maps to <code>complete: false</code>.</p>
<p>A V1 writer comes along and sets <code>complete: true</code> (which sets <code>status: &quot;done&quot;</code> on V3). Then, they change their mind, and set <code>complete: false</code>. What should V3 see? There are two reasonable answers here:</p>
<ol>
<li>V1 essentially did something and then undid it, so V3 should end up back where it was: <code>status: &quot;inProgress&quot;</code>.</li>
<li>When V1 sets <code>complete: false</code>, that should always set <code>status: &quot;todo&quot;</code> on the V3 doc. So, the V3 doc should end up</li>
</ol>
<p>In our project, we ended up deciding we wanted Option 2.</p>
<p>With an approach based on converting <em>documents</em> back and forth, Option 2 becomes very tricky. The V1 doc has ended up in the same state it was before, but we somehow want that to result in a change on the V3 doc!?</p>
<p>With the patch based approach of this implementation, this sequence of events is easy to reason about. Each <em>patch</em> on the V1 document is mapped to a corresponding patch on the V3 document, and we end up with <code>status: &quot;todo&quot;</code> just as we want.</p>
<p><a href="https://monodraw.helftone.com/">Monodraw</a> Source for the ASCII art is at <code>./chitin4.monopic</code>,</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://inkandswitch.github.io/cambria/" >
    &copy;  Cambria Development Notes 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/cambria/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
